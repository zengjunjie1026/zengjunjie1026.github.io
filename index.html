<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zengjunjie1026.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="做自己爱做的事，爱自己在做的事！">
<meta property="og:type" content="website">
<meta property="og:title" content="分子美食家的博客">
<meta property="og:url" content="https://zengjunjie1026.github.io/index.html">
<meta property="og:site_name" content="分子美食家的博客">
<meta property="og:description" content="做自己爱做的事，爱自己在做的事！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="andrew">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zengjunjie1026.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>分子美食家的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">分子美食家的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习的技能和遇到的问题</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">andrew</p>
  <div class="site-description" itemprop="description">做自己爱做的事，爱自己在做的事！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zengjunjie1026.github.io/2023/08/16/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="andrew">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分子美食家的博客">
      <meta itemprop="description" content="做自己爱做的事，爱自己在做的事！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 分子美食家的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/16/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">图数据库对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-16 21:19:30 / 修改时间：21:28:48" itemprop="dateCreated datePublished" datetime="2023-08-16T21:19:30+08:00">2023-08-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="图数据库的对比"><a href="#图数据库的对比" class="headerlink" title="图数据库的对比"></a>图数据库的对比</h4><table>
<thead>
<tr>
<th>图数据库</th>
<th>是否分布式</th>
<th>开发语言</th>
<th>支持的节点数量</th>
<th>原生图存储</th>
<th align="left">multi_model</th>
<th>查询语言</th>
<th>支持开发的语言</th>
<th>开发公司</th>
<th>落地的公司</th>
<th>是否开源</th>
<th>使用场景</th>
<th>开源地址</th>
<th>文档地址</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>neo4j</td>
<td>社区单机版&#x2F;商业是伪分布式</td>
<td>java</td>
<td>百亿</td>
<td>是</td>
<td align="left">否</td>
<td>cypher</td>
<td>java&#x2F;python</td>
<td>neo4j</td>
<td>使用非常广泛</td>
<td>否</td>
<td>OLAP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nebula graph</td>
<td>分布式</td>
<td>java</td>
<td>千亿个</td>
<td>是</td>
<td align="left">否</td>
<td>nsql</td>
<td>java</td>
<td></td>
<td>京东 &#x2F;360&#x2F;携程&#x2F;oppo&#x2F;各种银行</td>
<td></td>
<td>OLAP</td>
<td><a target="_blank" rel="noopener" href="https://github.com/vesoft-inc/nebula-graph">https://github.com/vesoft-inc/nebula-graph</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ultipa</td>
<td>分布式</td>
<td></td>
<td></td>
<td>是</td>
<td align="left">否</td>
<td></td>
<td></td>
<td>北京同心尚科技发展有限公司</td>
<td>金融行业</td>
<td>否</td>
<td>HTAP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>janusgraph</td>
<td>分布式</td>
<td>java</td>
<td></td>
<td>否</td>
<td align="left">是</td>
<td>gremlin</td>
<td>java</td>
<td>The Linux Foundation</td>
<td>apache顶级项目</td>
<td>是</td>
<td>OLAP</td>
<td><a target="_blank" rel="noopener" href="https://github.com/JanusGraph/janusgraph">https://github.com/JanusGraph/janusgraph</a></td>
<td><a target="_blank" rel="noopener" href="https://docs.janusgraph.org/">https://docs.janusgraph.org/</a></td>
<td></td>
</tr>
<tr>
<td>hugegraph</td>
<td>分布式</td>
<td>java</td>
<td></td>
<td>否</td>
<td align="left">是</td>
<td>gremlin</td>
<td>java</td>
<td>百度</td>
<td>百度</td>
<td>是</td>
<td>OLAP</td>
<td><a target="_blank" rel="noopener" href="https://github.com/hugegraph/hugegraph">https://github.com/hugegraph/hugegraph</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tugraph</td>
<td>分布式</td>
<td>C++</td>
<td></td>
<td>是</td>
<td align="left">否</td>
<td>cypher</td>
<td>C++</td>
<td>费马科技</td>
<td>京东金融、  搜狗 、国家电网</td>
<td>否</td>
<td>OLAP</td>
<td>wget <a target="_blank" rel="noopener" href="https://fma-ai.cn/download/lgraph_latest.tar">https://fma-ai.cn/download/lgraph_latest.tar</a></td>
<td><a target="_blank" rel="noopener" href="https://fma-ai.cn/help/">https://fma-ai.cn/help/</a></td>
<td></td>
</tr>
<tr>
<td>tigergraph</td>
<td>单机开发&#x2F;商业是分布式</td>
<td>C++</td>
<td>万亿</td>
<td>是</td>
<td align="left">否</td>
<td>GSQL</td>
<td></td>
<td>tighergraph</td>
<td>国家电网、国有银行</td>
<td>否</td>
<td>OLTP</td>
<td></td>
<td><a target="_blank" rel="noopener" href="https://www.tigergraph.com.cn/">https://www.tigergraph.com.cn/</a></td>
<td></td>
</tr>
<tr>
<td>geagraph</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>否</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="JanusGraph"><a href="#JanusGraph" class="headerlink" title="JanusGraph"></a>JanusGraph</h4><p>JanusGraph是一个可扩展的图数据库，可以把包含数千亿个顶点和边的图存储在多机集群上。它支持事务，支持数千用户实时、并发访问存储在其中的图。</p>
<p>anusGraph是2016年12月27日从Titan fork出来的一个分支<br>(1)分布式部署，因此，支持集群。<br>(2)可以存储大图，比如包含数千亿Vertices和edges的图。<br>(3)支持数千用户实时、并发访问。（并发访问肯定是实时的，这个唉，没必要强调好像）<br>(4)集群节点可以线性扩展，以支持更大的图和更多的并发访问用户。（Elastic and linear scalability for a growing data and user base）<br>(5)数据分布式存储，并且每一份数据都有多个副本，因此，有更好的计算性能和容错性。（Data distribution and replication for performance and fault tolerance）<br>(6)支持在多个数据中心做高可用，支持热备份。（Elastic and linear scalability for a growing data and user base）<br>(7)支持各种后端存储系统，目前标准支持以下四种，当然也可以增加第三方的存储系统：<br>Apache Cassandra®<br>Apache HBase®<br>Google Cloud Bigtable<br>Oracle BerkeleyDB<br>(8)通过集成大数据平台，比如Apache Spark、Apache Giraph、Apache Hadoop等，支持全局图数据分析、报表、ETL<br>(9)支持geo（Gene Expression Omnibus，基因数据分析）、numeric range（这个的含义不清楚）<br>(10)集成ElasticSearch、Apache Solr、Apache Lucene等系统后，可以支持全文搜索。<br>(11) 原生集成Apache TinkerPop图技术栈，包括Gremlin graph query language、Gremlin graph server、Gremin applications。<br>(12)开源，基于Apache 2 Licence。<br>(13)通过使用以下系统可以可视化存储在JanusGraph中的图数据：<br>Cytoscape<br>Gephi plugin for Apache TinkerPop<br>Graphexp<br>KeyLines by Cambridge Intelligence<br>Linkurious</p>
<p><img src="https://images2018.cnblogs.com/blog/513451/201805/513451-20180531112615520-1894246489.png" alt="avatar"></p>
<p>java语言开发，不支持python语言</p>
<ol>
<li><strong>性能</strong> 要求图查询及图分析算法的执行快，涉及到底层存储结构，原生图存储基于点和边，计算中不需要过多的逻辑和物理层转换。原生图存储(neo4j&#x2F;tigergraph)胜</li>
<li><strong>容量</strong> 大数据时代可获取的数据越来越多，单机的容量有限。原生图存储如何实现分布式存储是困难所在。TigerGraph自称是原生并行图；neo4j支持数据的高可用HA集群，但非分布式存储;JanusGraph利用HBase等NoSQL作为后端存储，在存储层面算是分布式的，容量可以很大。百度基于JanusGraph开源了HugeGraph，增加了很多特性，提高了易用性及性能，增加了一些图分析算法。</li>
<li><strong>查询能力</strong> 图数据库要具备点关系的查询能力，必不可少的如两点间所有路径，最短路径，多度查询等，这个一般都具备，差异主要是性能，普通图数据库查询3度及以上通常性能就很低了，而实际经常需要查询6度的关系，tigergraph自己的测试报告性能是很强劲的针对twitter的大图数据库，只有tigergraph完成了6度关系查询</li>
<li><strong>图分析计算能力</strong> 图数据库如果仅具备存储及查询能力，则还需要依赖外部的GraphX等计算引擎才能完成一些图算法分析，这样即在数据传输，又在图表达上存在转换浪费。TigerGraph可以通过GSQL实现类存储过程式的算法封装，且已实现了很多图算法<a href="https://link.zhihu.com/?target=https://www.tigergraph.com.cn/tigergraph%E5%BC%80%E6%BA%90%E5%8D%81%E5%A4%A7%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%97%E6%B3%95%E5%BA%93/">https://www.tigergraph.com.cn/tigergraph开源十大图数据库算法库/</a></li>
</ol>
<p>百度基于JanusGraph开源了HugeGraph，增加了很多特性，提高了易用性及性能，增加了一些图分析算法。</p>
<p><strong>JanusGraph&#x2F;HugeGraph</strong>是开源的，Apache协议，开放性最好</p>
<p><strong>neo4j</strong>社区版开源，非商用免费，商业版支持HA集群，并不是完全分布式，使用最广最流行</p>
<p><strong>TigerGraph</strong>将普通数据库归为第一第二代，自己为第三代，“TigerGraph是非常完备和优化的图数据库平台，支持大规模图存储以及大规模图的运行处理，具有非常强大的查询语言和算法库”。TigerGraph没有开源，<strong>开发者版支持单机单用户单图非商业免费，不支持DynamicSchemaChange等</strong>，图创建好之后也能通过界面手工去修改或添加，除非DropAll。TG的GSQL是类sql的语言，表达能力挺强，其将编写的query直接安装发布为restapi的形式让我感到很惊艳。目前TigerGraph的生态不是很全，编程api等能力也有一定限制，但值得尝试</p>
<p><img src="https://pic3.zhimg.com/v2-5abbeda0fb296d05d1516fcda2d3592e_r.jpg" alt="preview"></p>
<p>![image-20211109160429069](&#x2F;Users&#x2F;andrew&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211109160429069.png)</p>
<p>geagraph 阿里联合清华发布，没有开源</p>
<p><img src="https://pic2.zhimg.com/v2-2ce2bd623678dd5dbd42933d49b2d321_r.jpg" alt="preview"></p>
<p>janusgraph</p>
<p><img src="https://img-blog.csdnimg.cn/20190123101621250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pZQzg4ODg4,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>tugraph</p>
<p><img src="https://fma-ai.cn/cover/%E6%88%AA%E5%B1%8F2020-07-09%20%E4%B8%8B%E5%8D%881-1594348883927.png" alt="img"></p>
<p>cypher 语法，没有开源，估计是neo4j套皮</p>
<p><img src="https://pic4.zhimg.com/v2-88a8c5a05d2fe6e93d44ddd937a7cc98_r.jpg" alt="preview"></p>
<p>tigergraph</p>
<p>![image-20211111104734637](&#x2F;Users&#x2F;andrew&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211111104734637.png)</p>
<p><img src="https://img2018.cnblogs.com/blog/847408/201901/847408-20190118192620943-2101126015.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zengjunjie1026.github.io/2023/08/16/hbase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="andrew">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分子美食家的博客">
      <meta itemprop="description" content="做自己爱做的事，爱自己在做的事！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 分子美食家的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/16/hbase/" class="post-title-link" itemprop="url">hbase</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-16 21:16:22 / 修改时间：21:16:28" itemprop="dateCreated datePublished" datetime="2023-08-16T21:16:22+08:00">2023-08-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="HBase简介"><a href="#HBase简介" class="headerlink" title="HBase简介"></a>HBase简介</h2><h3 id="什么是HBase"><a href="#什么是HBase" class="headerlink" title="什么是HBase"></a>什么是HBase</h3><p>HBASE是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBASE技术可在廉价PC Server上搭建起大规模结构化存储集群。<br>HBASE的目标是存储并处理大型的数据，更具体来说是仅需使用普通的硬件配置，就能够处理由成千上万的行和列所组成的大型数据。HBASE是<br>Google Bigtable的开源实现，但是也有很多不同之处。比如：Google Bigtable利用GFS作为其文件存储系统，HBASE利用Hadoop<br>HDFS作为其文件存储系统；Google运行MAPREDUCE来处理Bigtable中的海量数据，HBASE同样利用Hadoop MapReduce来处理HBASE<br>中的海量数据；Google Bigtable利用Chubby作为协同服务，HBASE利用Zookeeper作为对应。</p>
<h3 id="HBase中的角色"><a href="#HBase中的角色" class="headerlink" title="HBase中的角色"></a>HBase中的角色</h3><h4 id="HMaster"><a href="#HMaster" class="headerlink" title="HMaster"></a>HMaster</h4><p>功能：</p>
<ul>
<li>监控RegionServer</li>
<li>处理RegionServer故障转移</li>
<li>处理元数据的变更</li>
<li>处理region的分配或移除</li>
<li>在空闲时间进行数据的负载均衡</li>
<li>通过Zookeeper发布自己的位置给客户端</li>
</ul>
<h4 id="RegionServer"><a href="#RegionServer" class="headerlink" title="RegionServer"></a>RegionServer</h4><p>功能：</p>
<ul>
<li>负责存储HBase的实际数据</li>
<li>处理分配给它的Region</li>
<li>刷新缓存到HDFS</li>
<li>维护HLog</li>
<li>执行压缩</li>
<li>负责处理Region分片</li>
</ul>
<h5 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h5><ul>
<li>Write-Ahead logs<br>HBase的修改记录，当对HBase读写数据的时候，数据不是直接写进磁盘，它会在内存中保留一段时间（时间以及数据量阈值可以设定）。<br>但把数据保存在内存中可能有更高的概率引起数据丢失，为了解决这个问题，数据会先写在一个叫做Write-Ahead logfile的文件中，<br>然后再写入内存中。所以在系统出现故障的时候，数据可以通过这个日志文件重建。</li>
<li>HFile<br>这是在磁盘上保存原始数据的实际的物理文件，是实际的存储文件。</li>
<li>Store<br>HFile存储在Store中，一个Store对应HBase表中的一个列族。</li>
<li>MemStore<br>顾名思义，就是内存存储，位于内存中，用来保存当前的数据操作，所以当数据保存在WAL中之后，RegsionServer会在内存中存储键值对。</li>
<li>Region<br>Hbase表的分片，HBase表会根据RowKey值被切分成不同的region存储在RegionServer中，在一个RegionServer中可以有多个不同的region。</li>
</ul>
<h3 id="HBase架构"><a href="#HBase架构" class="headerlink" title="HBase架构"></a>HBase架构</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfa9b3afd8f844d0b938825b77e085d2~tplv-k3u1fbpfcp-watermark.image"></p>
<h2 id="HBase安装"><a href="#HBase安装" class="headerlink" title="HBase安装"></a>HBase安装</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingyunzong/p/8668880.html">HBase学习之路 （二）HBase集群安装</a></li>
</ul>
<h2 id="HBase数据结构"><a href="#HBase数据结构" class="headerlink" title="HBase数据结构"></a>HBase数据结构</h2><h3 id="Row-Key"><a href="#Row-Key" class="headerlink" title="Row Key"></a>Row Key</h3><p>与nosql数据库们一样,row key是用来检索记录的主键。访问HBASE table中的行，只有三种方式：</p>
<ul>
<li>通过单个row key访问</li>
<li>通过row key的range（正则）</li>
<li>全表扫描Row key行键(Row key)可以是任意字符串(最大长度是64KB，实际应用中长度一般为10-100bytes)，在HBASE内部，<br>row key保存为字节数组。存储时，数据按照Row key的字典序(byte order)排序存储。设计key时，要充分排序存储这个特性，将经常一起读取的行存储放到一起。(位置相关性)</li>
</ul>
<h3 id="Columns-Family"><a href="#Columns-Family" class="headerlink" title="Columns Family"></a>Columns Family</h3><p>列族：HBASE表中的每个列，都归属于某个列族。列族是表的schema的一部分(而列不是)，必须在使用表之前定义。列名都以列族作为前缀。例如courses:history，courses:math都属于courses 这个列族。</p>
<h3 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h3><p>由{row key, columnFamily, version} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存贮。关键字：无类型、字节码</p>
<h3 id="Time-Stamp"><a href="#Time-Stamp" class="headerlink" title="Time Stamp"></a>Time Stamp</h3><p>HBASE 中通过rowkey和columns确定的为一个存贮单元称为cell。每个cell都保存着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是64位整型。时间戳可以由HBASE(在数据写入时自动)赋值，此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显式赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。每个cell中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。为了避免数据存在过多版本造成的的管理(包括存贮和索引)负担，HBASE提供了两种数据版本回收方式。一是保存数据的最后n个版本，二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</p>
<h2 id="HBase原理"><a href="#HBase原理" class="headerlink" title="HBase原理"></a>HBase原理</h2><h3 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf7e99f7965d4f3b9b4e54961088cc1a~tplv-k3u1fbpfcp-watermark.image"></p>
<ul>
<li>Client向HregionServer发送写请求；</li>
<li>HregionServer将数据写到HLog（write ahead log）。为了数据的持久化和恢复；</li>
<li>HregionServer将数据写到内存（MemStore）；</li>
<li>反馈Client写成功。</li>
</ul>
<h3 id="数据flush过程"><a href="#数据flush过程" class="headerlink" title="数据flush过程"></a>数据flush过程</h3><ul>
<li>当MemStore数据达到阈值（默认是128M，老版本是64M），将数据刷到硬盘，将内存中的数据删除，同时删除HLog中的历史数据；</li>
<li>并将数据存储到HDFS中；</li>
<li>在HLog中做标记点。</li>
</ul>
<h3 id="数据合并过程"><a href="#数据合并过程" class="headerlink" title="数据合并过程"></a>数据合并过程</h3><ul>
<li>当数据块达到4块，Hmaster将数据块加载到本地，进行合并；</li>
<li>当合并的数据超过256M，进行拆分，将拆分后的Region分配给不同的HregionServer管理；</li>
<li>当HregionServer宕机后，将HregionServer上的hlog拆分，然后分配给不同的HregionServer加载，修改.META；</li>
<li>注意：HLog会同步到HDFS。</li>
</ul>
<h3 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e781efc3fd947d48e1d07bf17ee8426~tplv-k3u1fbpfcp-watermark.image"></p>
<ul>
<li>Client先访问zookeeper，从meta表读取region的位置，然后读取meta表中的数据。meta中又存储了用户表的region信息；</li>
<li>根据namespace、表名和rowkey在meta表中找到对应的region信息；</li>
<li>找到这个region对应的regionserver；</li>
<li>查找对应的region；</li>
<li>先从MemStore找数据，如果没有，再到StoreFile上读(为了读取的效率)。</li>
</ul>
<h3 id="Hmaster的职责"><a href="#Hmaster的职责" class="headerlink" title="Hmaster的职责"></a>Hmaster的职责</h3><ul>
<li>管理用户对Table的增、删、改、查操作；</li>
<li>记录region在哪台Hregion server上；</li>
<li>在Region Split后，负责新Region的分配；</li>
<li>新机器加入时，管理HRegion Server的负载均衡，调整Region分布；</li>
<li>在HRegion Server宕机后，负责失效HRegion Server 上的Regions迁移。</li>
</ul>
<h3 id="Hregionserver的职责"><a href="#Hregionserver的职责" class="headerlink" title="Hregionserver的职责"></a>Hregionserver的职责</h3><ul>
<li>HRegion Server主要负责响应用户I&#x2F;O请求，向HDFS文件系统中读写数据，是HBASE中最核心的模块。</li>
<li>HRegion Server管理了很多table的分区，也就是region。</li>
</ul>
<h3 id="Client职责"><a href="#Client职责" class="headerlink" title="Client职责"></a>Client职责</h3><ul>
<li>HBASE Client使用HBASE的RPC机制与HMaster和RegionServer进行通信</li>
<li>管理类操作：Client与HMaster进行RPC；</li>
<li>数据读写类操作：Client与HRegionServer进行RPC。</li>
</ul>
<h2 id="Phoenix-SQL-On-HBase"><a href="#Phoenix-SQL-On-HBase" class="headerlink" title="Phoenix(SQL On HBase)"></a>Phoenix(SQL On HBase)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>Phoenix是一个HBase框架，可以通过SQL的方式来操作HBase。</li>
<li>Phoenix是构建在HBase上的一个SQL层，是内嵌在HBase中的JDBC驱动，能够让用户使用标准的JDBC来操作HBase。</li>
<li>Phoenix使用JAVA语言进行编写，其查询引擎会将SQL查询语句转换成一个或多个HBase Scanner，且并行执行生成标准的JDBC结果集。</li>
<li>如果需要对HBase进行复杂的操作，那么应该使用Phoenix，其会将SQL语句转换成HBase相应的API。</li>
<li>Phoenix只能用在HBase上，其查询性能要远高于Hive。</li>
</ul>
<h3 id="Phoenix与HBase的关系"><a href="#Phoenix与HBase的关系" class="headerlink" title="Phoenix与HBase的关系"></a>Phoenix与HBase的关系</h3><p>Phoenix与HBase中的表是独立的，两者之间没有必然的关系。</p>
<p>Phoenix与HBase集成后会创建六张系统表：SYSTEM.CATALOG、SYSTEM.FUNCTION、SYSTEM.LOG、SYSTEM.SEQUENCE、SYSTEM.STATS，其中SYSTEM.CATALOG表用于存放Phoenix创建表时的元数据。</p>
<p>Phoenix创建表时会自动调用HBase客户端创建相应的表，并且在SYSTEM.CATALOG系统表中记录Phoenix创建表时的元数据，其主键的值对应HBase的RowKey，非主键的列对应HBase的Column（列族不指定时为0，且列会进行编码）</p>
<p>如果是通过Phoenix创建的表，那么必须通过Phoenix客户端来对表进行操作，因为通过Phoenix创建的表其非主键的列会进行编码。</p>
<h3 id="Phoenix语法"><a href="#Phoenix语法" class="headerlink" title="Phoenix语法"></a>Phoenix语法</h3><p>Phoenix的SQL中如果表名、字段名不使用双引号标注那么默认转换成大写。</p>
<p>Phoenix中的字符串使用单引号进行标注。 </p>
<p>创建表</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS us_population (</span><br><span class="line">      <span class="keyword">state</span> CHAR(<span class="number">2</span>) NOT NULL,</span><br><span class="line">      city VARCHAR NOT NULL,</span><br><span class="line">      population BIGINT</span><br><span class="line">      CONSTRAINT my_pk PRIMARY KEY (<span class="keyword">state</span>, city)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主键的值对应HBase中的RowKey，列族不指定时默认是0，非主键的列对应HBase的列。</p>
</blockquote>
<p>删除表</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> us_population;</span><br></pre></td></tr></table></figure>

<p>查询数据</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> us_population <span class="keyword">WHERE</span> state = <span class="string">&#x27;NA&#x27;</span> <span class="keyword">AND</span> population &gt; <span class="number">10000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> population <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在进行查询时，支持ORDER BY、GROUP BY、LIMIT、JOIN等操作，同时Phoenix提供了一系列的函数，其中包括COUNT()、MAX()、MIN()、SUM()等，具体的函数列表可以查看：<a target="_blank" rel="noopener" href="http://phoenix.apache.org/language/functions.html%E4%B8%8D%E7%AE%A1%E6%9D%A1%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%88%97%E6%98%AF%E5%90%A6%E6%98%AF%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE%E4%B8%AD%E7%9A%84%EF%BC%8CPhoenix%E4%B8%80%E6%A0%B7%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%8C%81%E3%80%82">http://phoenix.apache.org/language/functions.html不管条件中的列是否是联合主键中的，Phoenix一样可以支持。</a></p>
</blockquote>
<p> 删除数据</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM us_population WHERE <span class="keyword">state</span> = &#x27;NA&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Phoenix映射HBase </p>
<p>只要直接通过HBase客户端创建的表，若想用Phoenix来进行操作，那么必须要进行表的映射，因为SYSTEM.CATALOG表中并没有维护Phoenix创建表的元数据。</p>
<p>创建表来进行表的映射</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 表名(</span><br><span class="line">  列名 类型 主键,</span><br><span class="line">  列簇.列名,</span><br><span class="line">  列簇.列名</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>HBase中的RowKey映射Phoenix的主键，HBase中的Column映射Phoenix的列，且使用列簇名.列名进行映射。<br>相当于在SYSTEM.CATALOG表中录入相关的元数据，使Phoenix能够进行操作它。</p>
<h3 id="使用二级索引"><a href="#使用二级索引" class="headerlink" title="使用二级索引"></a>使用二级索引</h3><p>在HBase中会自动为RowKey添加索引，因此在通过RowKey查询数据时效率会很高，但是如果要根据其他列来进行组合查询，那么查询的性能就很低下，此时可以使用Phoenix提供的二级索引，能够极大的提高查询数据的性能。</p>
<p> 我们其实已经知道了我们的主键 是和我们的rowkey进行映射的，所以查询性能高</p>
<ul>
<li>创建普通索引<blockquote>
<p>CREATE INDEX 索引名称 ON 表名(列名)</p>
</blockquote>
</li>
<li>创建二级索引<blockquote>
<p>CREATE INDEX 索引名称 ON 表名(列名) INCLUDE(列名)</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zengjunjie1026.github.io/2023/08/16/RAID%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="andrew">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分子美食家的博客">
      <meta itemprop="description" content="做自己爱做的事，爱自己在做的事！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 分子美食家的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/16/RAID%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">RAID技术简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-16 21:11:00 / 修改时间：21:28:53" itemprop="dateCreated datePublished" datetime="2023-08-16T21:11:00+08:00">2023-08-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：王奥<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20131784/answer/90235520">https://www.zhihu.com/question/20131784/answer/90235520</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>title: RAID磁盘阵列配置和调优小结<br>date: 2016-03-10 15:52:17<br>categories: 学习 | Study<br>description: RAID的本质是平衡可用性与成本<br>-–</p>
<p><img src="https://pica.zhimg.com/50/3d84e446492f99c8082089313c3944ac_720w.jpg?source=1940ef5c" alt="img"><img src="https://pica.zhimg.com/80/3d84e446492f99c8082089313c3944ac_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>## 前言</strong></p>
<p>RAID解释我偷个小懒引用WikipediA，独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks），旧称廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。根据选择的版本不同，RAID比单颗硬盘有以下一个或多个方面的好处：增强数据集成度，增强容错功能，增加处理量或容量。另外，磁盘阵列对于电脑来说，看起来就像一个单独的硬盘或逻辑存储单元。写这篇文章当然不是单纯的介绍概念和使用方法，更重要的是如何针对不同的业务场景做合理的RAID配置和参数优化，对于SSD固态硬盘的加入我引入小米运维团队的实验数据，同时我也相信分布式存储会逐步走向成熟，以OpenStack，VSAN，Nutanix为代表头顶软件定义和超融合概念的技术也已经开始了暗战。</p>
<p>&gt; RAID的本质是平衡可用性与成本  </p>
<p>-–</p>
<p><strong>## 更新历史</strong></p>
<p>2016年03月11日 - 初稿</p>
<p>阅读原文 - <a href="https://link.zhihu.com/?target=http://wsgzao.github.io/post/raid/">RAID磁盘阵列配置和调优小结</a></p>
<p><strong>扩展阅读</strong></p>
<p>RAID - <a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/RAID">https://zh.wikipedia.org/wiki/RAID</a><br>RAID技术发展综述 - <a href="https://link.zhihu.com/?target=http://blog.csdn.net/liuaigui/article/details/4581970">RAID技术发展综述</a><br>SSD阵列卡方案优化：考虑使用RAID 50替代RAID 10 - <a href="https://link.zhihu.com/?target=http://noops.me/?p=1805">SSD阵列卡方案优化：考虑使用RAID 50替代RAID 10</a></p>
<p>-–</p>
<p><strong>## RAID基础知识</strong></p>
<p>&gt;感谢@刘爱贵，详细知识点可参考扩展阅读</p>
<p>### 基本原理</p>
<p>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，通常简称为磁盘阵列。简单地说， RAID 是由多个独立的高性能磁盘驱动器组成的磁盘子系统，从而提供比单个磁盘更高的存储性能和数据冗余的技术。 RAID 是一类多磁盘管理技术，其向主机环境提供了成本适中、数据可靠性高的高性能存储。 SNIA 对 RAID 的定义是 ：一种磁盘阵列，部分物理存储空间用来记录保存在剩余空间上的用户数据的冗余信息。当其中某一个磁盘或访问路径发生故障时，冗余信息可用来重建用户数据。磁盘条带化虽然与 RAID 定义不符，通常还是称为 RAID （即 RAID0 ）。</p>
<p>RAID 的初衷是为大型服务器提供高端的存储功能和冗余的数据安全。在整个系统中， RAID 被看作是由两个或更多磁盘组成的存储空间，通过并发地在多个磁盘上读写数据来提高存储系统的 I&#x2F;O 性能。大多数 RAID 等级具有完备的数据校验、纠正措施，从而提高系统的容错性，甚至镜像方式，大大增强系统的可靠性， Redundant 也由此而来。</p>
<p>这里要提一下 JBOD （ Just a Bunch of Disks ）。最初 JBOD 用来表示一个没有控制软件提供协调控制的磁盘集合，这是 RAID 区别与 JBOD 的主要因素。目前 JBOD 常指磁盘柜，而不论其是否提供 RAID 功能。</p>
<p>RAID 的两个关键目标是提高数据可靠性和 I&#x2F;O 性能。磁盘阵列中，数据分散在多个磁盘中，然而对于计算机系统来说，就像一个单独的磁盘。通过把相同数据同时写入到多块磁盘（典型地如镜像），或者将计算的校验数据写入阵列中来获得冗余能力，当单块磁盘出现故障时可以保证不会导致数据丢失。有些 RAID 等级允许更多地 磁盘同时发生故障，比如 RAID6 ，可以是两块磁盘同时损坏。在这样的冗余机制下，可以用新磁盘替换故障磁盘， RAID 会自动根据剩余磁盘中的数据和校验数据重建丢失的数据，保证数据一致性和完整性。数据分散保存在 RAID 中的多个不同磁盘上，并发数据读写要大大优于单个磁盘，因此可以获得更高的聚合 I&#x2F;O 带宽。当然，磁盘阵列会减少全体磁盘的总可用存储空间，牺牲空间换取更高的可靠性和性能。比如， RAID1 存储空间利用率仅有 50% ， RAID5 会损失其中一个磁盘的存储容量，空间利用率为 (n-1)&#x2F;n 。</p>
<p>磁盘阵列可以在部分磁盘（单块或多块，根据实现而论）损坏的情况下，仍能保证系统不中断地连续运行。在重建故障磁盘数据至新磁盘的过程中，系统可以继续正常运行，但是性能方面会有一定程度上的降低。一些磁盘阵列在添加或删除磁盘时必须停机，而有些则支持热交换 （ Hot Swapping ），允许不停机下替换磁盘驱动器。这种高端磁盘阵列主要用于要求高可能性的应用系统，系统不能停机或尽可能少的停机时间。一般来说， RAID 不可作为数据备份的替代方案，它对非磁盘故障等造成的数据丢失无能为力，比如病毒、人为破坏、意外删除等情形。此时的数据丢失是相对操作系统、文件系统、卷管理器或者应用系统来说的，对于 RAID 系统来身，数据都是完好的，没有发生丢失。所以，数据备份、灾 备等数据保护措施是非常必要的，与 RAID 相辅相成，保护数据在不同层次的安全性，防止发生数据丢失。</p>
<p>RAID 中主要有三个关键概念和技术：镜像（ Mirroring ）、数据条带（ Data Stripping ）和数据校验（ Data parity ）。镜像，将数据复制到多个磁盘，一方面可以提高可靠性，另一方面可并发从两个或多个副本读取数据来提高读性能。显而易见，镜像的写性能要稍低， 确保数据正确地写到多个磁盘需要更多的时间消耗。数据条带，将数据分片保存在多个不同的磁盘，多个数据分片共同组成一个完整数据副本，这与镜像的多个副本是不同的，它通常用于性能考虑。数据条带具有更高的并发粒度，当访问数据时，可以同时对位于不同磁盘上数据进行读写操作， 从而获得非常可观的 I&#x2F;O 性能提升 。数据校验，利用冗余数据进行数据错误检测和修复，冗余数据通常采用海明码、异或操作等算法来计算获得。利用校验功能，可以很大程度上提高磁盘阵列的可靠性、鲁棒性和容错能力。不过，数据校验需要从多处读取数据并进行计算和对比，会影响系统性能。 不同等级的 RAID 采用一个或多个以上的三种技术，来获得不同的数据可靠性、可用性和 I&#x2F;O 性能。至于设计何种 RAID （甚至新的等级或类型）或采用何种模式的 RAID ，需要在深入理解系统需求的前提下进行合理选择，综合评估可靠性、性能和成本来进行折中的选择。</p>
<p>RAID 思想从提出后就广泛被业界所接纳，存储工业界投入了大量的时间和财力来研究和开发相关产品。而且，随着处理器、内存、计算机接口等技术的不断发展， RAID 不断地发展和革新，在计算机存储领域得到了广泛的应用，从高端系统逐渐延伸到普通的中低端系统。 RAID 技术如此流行，源于其具有显著的特征和优势，基本可以满足大部分的数据存储需求。总体说来， RAID 主要优势有如下几点：<br>(1) 大容量<br>　　这是 RAID 的一个显然优势，它扩大了磁盘的容量，由多个磁盘组成的 RAID 系统具有海量的存储空间。现在单个磁盘的容量就可以到 1TB 以上，这样 RAID 的存储容量就可以达到 PB 级，大多数的存储需求都可以满足。一般来说， RAID 可用容量要小于所有成员磁盘的总容量。不同等级的 RAID 算法需要一定的冗余开销，具体容量开销与采用算法相关。如果已知 RAID 算法和容量，可以计算出 RAID 的可用容量。通常， RAID 容量利用率在 50% ~ 90% 之间。<br>(2) 高性能<br>　　 RAID 的高性能受益于数据条带化技术。单个磁盘的 I&#x2F;O 性能受到接口、带宽等计算机技术的限制，性能往往很有 限，容易成为系统性能的瓶颈。通过数据条带化， RAID 将数据 I&#x2F;O 分散到各个成员磁盘上，从而获得比单个磁盘成倍增长的聚合 I&#x2F;O 性能。<br>(3) 可靠性<br>　　可用性和可靠性是 RAID 的另一个重要特征。从理论上讲，由多个磁盘组成的 RAID 系统在可靠性方面应该比单个磁盘要差。这里有个隐含假定：单个磁盘故障将导致整个 RAID 不可用。 RAID 采用镜像和数据校验等数据冗余技术，打破了这个假定。 镜像是最为原始的冗余技术，把某组磁盘驱动器上的数据完全复制到另一组磁盘驱动器上，保证总有数据副本可用。 比起镜像 50% 的冗余开销 ，数据校验要小很多，它利用校验冗余信息对数据进行校验和纠错。 RAID 冗余技术大幅提升数据可用性和可靠性，保证了若干磁盘出错时，不 会导致数据的丢失，不影响系统的连续运行。<br>(4) 可管理性<br>　　实际上， RAID 是一种虚拟化技术，它对多个物理磁盘驱动器虚拟成一个大容量的逻辑驱动器。对于外部主机系统来说， RAID 是一个单一的、快速可靠的大容量磁盘驱动器。这样，用户就可以在这个虚拟驱动器上来组织和存储应用系统数据。 从用户应用角度看，可使存储系统简单易用，管理也很便利。 由于 RAID 内部完成了大量的存储管理工作，管理员只需要管理单个虚拟驱动器，可以节省大量的管理工作。 RAID 可以动态增减磁盘驱动器，可自动进行数据校验和数据重建，这些都可以 大大简化管理工作。</p>
<p><strong>### 关键技术</strong></p>
<p>&gt; 镜像</p>
<p>镜像是一种冗余技术，为磁盘提供保护功能，防止磁盘发生故障而造成数据丢失。对于 RAID 而言，采用镜像技术 典型地 将会同时在阵列中产生两个完全相同的数据副本，分布在两个不同的磁盘驱动器组上。镜像提供了完全的数据冗余能力，当一个数据副本失效不可用时，外部系统仍可正常访问另一副本，不会对应用系统运行和性能产生影响。而且，镜像不需要额外的计算和校验，故障修复非常快，直接复制即可。镜像技术可以从多个副本进行并发读取数据，提供更高的读 I&#x2F;O 性能，但不能并行写数据，写多个副本会会导致一定的 I&#x2F;O 性能降低。</p>
<p>镜像技术提供了非常高的数据安全性，其代价也是非常昂贵的，需要　　　至少双倍的存储空间。高成本限制了镜像的广泛应用，主要应用于至关重要的数据保护，这种场合下数据丢失会造成巨大的损失。另外，镜像通过 “ 拆分 ” 能获得特定时间点的上数据快照，从而可以实现一种备份窗口几乎为零的数据备份技术。</p>
<p>&gt; 数据条带</p>
<p>磁盘存储的性能瓶颈在于磁头寻道定位，它是一种慢速机械运动，无法与高速的 CPU 匹配。再者，单个磁盘驱动器性能存在物理极限， I&#x2F;O 性能非常有限。 RAID 由多块磁盘组成，数据条带技术将数据以块的方式分布存储在多个磁盘中，从而可以对数据进行并发处理。这样写入和读取数据就可以在多个磁盘上同时进行，并发产生非常高的聚合 I&#x2F;O ，有效提高了整体 I&#x2F;O 性能，而且具有良好的线性扩展性。这对大容量数据尤其显著，如果不分块，数据只能按顺序存储在磁盘阵列的磁盘上，需要时再按顺序读取。而通过条带技术，可获得数倍与顺序访问的性能提升。</p>
<p>数据条带技术的分块大小选择非常关键。条带粒度可以是一个字节至几 KB 大小，分块越小，并行处理能力就越强，数据存取速度就越高，但同时就会增加块存取的随机性和块寻址时间。实际应用中，要根据数据特征和需求来选择合适的分块大小，在数据存取随机性和并发处理能力之间进行平衡，以争取尽可能高的整体性能。</p>
<p>数据条带是基于提高 I&#x2F;O 性能而提出的，也就是说它只关注性能， 而对数据可靠性、可用性没有任何改善。实际上，其中任何一个数据条带损坏都会导致整个数据不可用，采用数据条带技术反而增加了数据发生丢失的概念率。</p>
<p>&gt; 数据校验</p>
<p>镜像具有高安全性、高读性能，但冗余开销太昂贵。数据条带通过并发性来大幅提高性能，然而对数据安全性、可靠性未作考虑。数据校验是一种冗余技术，它用校验数据来提供数据的安全，可以检测数据错误，并在能力允许的前提下进行数据重构。相对镜像，数据校验大幅缩减了冗余开销，用较小的代价换取了极佳的数据完整性和可靠性。数据条带技术提供高性能，数据校验提供数据安全性， RAID 不同等级往往同时结合使用这两种技术。</p>
<p>采用数据校验时， RAID 要在写入数据同时进行校验计算，并将得到的校验数据存储在 RAID 成员磁盘中。校验数据可以集中保存在某个磁盘或分散存储在多个不同磁盘中，甚至校验数据也可以分块，不同 RAID 等级实现各不相同。当其中一部分数据出错时，就可以对剩余数据和校验数据进行反校验计算重建丢失的数据。校验技术相对于镜像技术的优势在于节省大量开销，但由于每次数据读写都要进行大量的校验运算，对计算机的运算速度要求很高，必须使用硬件 RAID 控制器。在数据重建恢复方面，检验技术比镜像技术复杂得多且慢得多。</p>
<p>海明校验码和 异或校验是两种最为常用的 数据校验算法。海明校验码是由理查德 · 海明提出的，不仅能检测错误，还能给出错误位置并自动纠正。海明校验的基本思想是：将有效信息按照某种规律分成若干组，对每一个组作奇偶测试并安排一个校验位，从而能提供多位检错信息，以定位错误点并纠正。可见海明校验实质上是一种多重奇偶校验。异或校验通过异或逻辑运算产生，将一个有效信息与一个给定的初始值进行异或运算，会得到校验信息。如果有效信息出现错误，通过校验信息与初始值的异或运算能还原正确的有效信息。</p>
<p><strong>## 常见RAID类型</strong></p>
<p>&gt; 常见5种RAID类型对比，n位磁盘数量，详细介绍可参考扩展阅读</p>
<table>
<thead>
<tr>
<th>RAID 等级</th>
<th>RAID0</th>
<th>RAID1</th>
<th>RAID5</th>
<th>RAID6</th>
<th>RAID10</th>
</tr>
</thead>
<tbody><tr>
<td>别名</td>
<td>条带</td>
<td>镜像</td>
<td>分布奇偶校验条带</td>
<td>双重奇偶校验条带</td>
<td>镜像加条带</td>
</tr>
<tr>
<td>容错性</td>
<td>无</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>冗余类型</td>
<td>无</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>热备盘</td>
<td>无</td>
<td>有</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>读性能</td>
<td>高</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>随机写性能</td>
<td>高</td>
<td>低</td>
<td>一般</td>
<td>低</td>
<td>一般</td>
</tr>
<tr>
<td>连续写性能</td>
<td>高</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>一般</td>
</tr>
<tr>
<td>需要磁盘数</td>
<td>n≥1</td>
<td>2n (n≥1)</td>
<td>n≥3</td>
<td>n≥4</td>
<td>2n(n≥2)≥4</td>
</tr>
<tr>
<td>可用容量</td>
<td>全部</td>
<td>50%</td>
<td>(n-1)&#x2F;n</td>
<td>(n-2)&#x2F;n</td>
<td>50%</td>
</tr>
</tbody></table>
<p><strong>## RAID 等级</strong></p>
<p><strong>### 标准 RAID 等级</strong></p>
<p>SNIA 、 Berkeley 等组织机构把 RAID0 、 RAID1 、 RAID2 、 RAID3 、 RAID4 、 RAID5 、 RAID6 七个等级定为标准的 RAID 等级，这也被业界和学术界所公认。标准等级是最基本的 RAID 配置集合，单独或综合利用数据条带、镜像和数据校验技术。标准 RAID 可以组合，即 RAID 组合等级，满足 对性能、安全性、可靠性要求更高的存储应用需求。</p>
<p><strong>### JBOD</strong></p>
<p>JBOD （ Just a Bunch Of Disks ）不是标准的 RAID 等级，它通常用来表示一个没有控制软件提供协调控制的磁盘集合。 JBOD 将多个物理磁盘串联起来，提供一个巨大的逻辑磁盘。 JBOD 的数据存放机制是由第一块磁盘开始按顺序往后存储，当前磁盘存储空间用完后，再依次往后面的磁盘存储数据。 JBOD 存储性能完全等同于单块磁盘，而且也不提供数据安全保护。它只是简单提供一种扩展存储空间的机制， JBOD 可用存储容量等于所有成员磁盘的存储空间之和。目前 JBOD 常指磁盘柜，而不论其是否提供 RAID 功能。</p>
<p><img src="https://pic3.zhimg.com/50/4cfb57a1c97a239af039a04697baab27_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/4cfb57a1c97a239af039a04697baab27_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>### RAID0</strong></p>
<p>RAID0 是一种简单的、无数据校验的数据条带化技术。实际上不是一种真正的 RAID ，因为它并不提供任何形式的冗余策略。 RAID0 将所在磁盘条带化后组成大容量的存储空间，将数据分散存储在所有磁盘中，以独立访问方式实现多块磁盘的并读访问。由于可以并发执行 I&#x2F;O 操作，总线带宽得到充分利用。再加上不需要进行数据校验， RAID0 的性能在所有 RAID 等级中是最高的。理论上讲，一个由 n 块磁盘组成的 RAID0 ，它的读写性能是单个磁盘性能的 n 倍，但由于总线带宽等多种因素的限制，实际的性能提升低于理论值。</p>
<p>RAID0 具有低成本、高读写性能、 100% 的高存储空间利用率等优点，但是它不提供数据冗余保护，一旦数据损坏，将无法恢复。 因此， RAID0 一般适用于对性能要求严格但对数据安全性和可靠性不高的应用，如视频、音频存储、临时数据缓存空间等。</p>
<p><img src="https://pic3.zhimg.com/50/0ab608c6eef8e74f926f9c1e89753a99_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/0ab608c6eef8e74f926f9c1e89753a99_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>### RAID1</strong></p>
<p>RAID1 称为镜像，它将数据完全一致地分别写到工作磁盘和镜像 磁盘，它的磁盘空间利用率为 50% 。 RAID1 在数据写入时，响应时间会有所影响，但是读数据的时候没有影响。 RAID1 提供了最佳的数据保护，一旦工作磁盘发生故障，系统自动从镜像磁盘读取数据，不会影响用户工作。</p>
<p>RAID1 与 RAID0 刚好相反，是为了增强数据安全性使两块 磁盘数据呈现完全镜像，从而达到安全性好、技术简单、管理方便。 RAID1 拥有完全容错的能力，但实现成本高。 RAID1 应用于对顺序读写性能要求高以及对数据保护极为重视的应用，如对邮件系统的数据保护。</p>
<p><img src="https://pic1.zhimg.com/50/595a2d853196c5b38ceee5d98032baeb_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/595a2d853196c5b38ceee5d98032baeb_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>### RAID5</strong></p>
<p>RAID5 应该是目前最常见的 RAID 等级，它的原理与 RAID4 相似，区别在于校验数据分布在阵列中的所有磁盘上，而没有采用专门的校验磁盘。对于数据和校验数据，它们的写操作可以同时发生在完全不同的磁盘上。因此， RAID5 不存在 RAID4 中的并发写操作时的校验盘性能瓶颈问题。另外， RAID5 还具备很好的扩展性。当阵列磁盘 数量增加时，并行操作量的能力也随之增长，可比 RAID4 支持更多的磁盘，从而拥有更高的容量以及更高的性能。</p>
<p>RAID5 的磁盘上同时存储数据和校验数据，数据块和对应的校验信息存保存在不同的磁盘上，当一个数据盘损坏时，系统可以根据同一条带的其他数据块和对应的校验数据来重建损坏的数据。与其他 RAID 等级一样，重建数据时， RAID5 的性能会受到较大的影响。</p>
<p>RAID5 兼顾存储性能、数据安全和存储成本等各方面因素，它可以理解为 RAID0 和 RAID1 的折中方案，是目前综合性能最佳的数据保护解决方案。 RAID5 基本上可以满足大部分的存储应用需求，数据中心大多采用它作为应用数据的保护方案。</p>
<p><img src="https://pic1.zhimg.com/50/8ff9b2beeaf295dd1f41d98af50d1ebf_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/8ff9b2beeaf295dd1f41d98af50d1ebf_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>### RAID6</strong></p>
<p>前面所 述的各个 RAID 等级都只能保护因单个磁盘失效而造成的数据丢失。如果两个磁盘同时发生故障，数据将无法恢复。 RAID6 引入双重校验的概念，它可以保护阵列中同时出现两个磁盘失效时，阵列仍能够继续工作，不会发生数据丢失。 RAID6 等级是在 RAID5 的基础上为了进一步增强数据保护而设计的一种 RAID 方式，它可以看作是一种扩展的 RAID5 等级。</p>
<p>RAID6 不仅要支持数据的恢复，还要支持校验数据的恢复，因此实现代价很高，控制器的设计也比其他等级更复杂、更昂贵。 RAID6 思想最常见的实现方式是采用两个独立的校验算法，假设称为 P 和 Q ，校验数据可以分别存储在两个不同的校验盘上，或者分散存储在所有成员磁盘中。当两个磁盘同时失效时，即可通过求解两元方程来重建两个磁盘上的数据。</p>
<p>RAID6 具有快速的读取性能、更高的容错能力。但是，它的成本要高于 RAID5 许多，写性能也较差，并有设计和实施非常复杂。因此， RAID6 很少得到实际应用，主要用于对数据安全等级要求非常高的场合。它一般是替代 RAID10 方案的经济性选择</p>
<p><img src="https://pic2.zhimg.com/50/e3d61ad32bd894385be86e3c1fcc8ff7_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/e3d61ad32bd894385be86e3c1fcc8ff7_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>### RAID 组合等级</strong></p>
<p>标准 RAID 等级各有优势和不足。自然地，我们想到把多个 RAID 等级组合起来，实现优势互补，弥补相互的不足，从而达到在性能、数据安全性等指标上更高的 RAID 系统。目前在业界和学术研究中提到的 RAID 组合等级主要有 RAID00 、 RAID01 、 RAID10 、 RAID100 、 RAID30 、 RAID50 、 RAID53 、 RAID60 ，但实际得到较为广泛应用的只有 RAID01 和 RAID10 两个等级。当然，组合等级的实现成本一般都非常昂贵，只是在 少数特定场合应用。</p>
<p><strong>### RAID10 和 RAID01</strong></p>
<p>一些文献把这两种 RAID 等级看作是等同的，本文认为是不同的。 RAID01 是先做条带化再作镜像，本质是对物理磁盘实现镜像；而 RAID10 是先做镜像再作条带化，是对虚拟磁盘实现镜像。相同的配置下，通常 RAID01 比 RAID10 具有更好的容错能力。</p>
<p>RAID01 兼备了 RAID0 和 RAID1 的优点，它先用两块磁盘建立镜像，然后再在镜像内部做条带化。 RAID01 的数据将同时写入到两个磁盘阵列中，如果其中一个阵列损坏，仍可继续工作，保证数据安全性的同时又提高了性能。 RAID01 和 RAID10 内部都含有 RAID1 模式，因此整体磁盘利用率均仅为 50% 。</p>
<p><img src="https://pic2.zhimg.com/50/29966aef58264fa7eabd94b2baa2fe43_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic2.zhimg.com/80/29966aef58264fa7eabd94b2baa2fe43_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><img src="https://pica.zhimg.com/50/b522ccd35950243675d164bbdb36011e_720w.jpg?source=1940ef5c" alt="img"><img src="https://pica.zhimg.com/80/b522ccd35950243675d164bbdb36011e_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>### RAID 50</strong></p>
<p>RAID 5与RAID 0的组合，先作RAID 5，再作RAID 0，也就是对多组RAID 5彼此构成Stripe访问。由于RAID 50是以RAID 5为基础，而RAID 5至少需要3颗硬盘，因此要以多组RAID 5构成RAID 50，至少需要6颗硬盘。以RAID 50最小的6颗硬盘配置为例，先把6颗硬盘分为2组，每组3颗构成RAID 5，如此就得到两组RAID 5，然后再把两组RAID 5构成RAID 0。</p>
<p>RAID 50在底层的任一组或多组RAID 5中出现1颗硬盘损坏时，仍能维持运作，不过如果任一组RAID 5中出现2颗或2颗以上硬盘损毁，整组RAID 50就会失效。</p>
<p>RAID 50由于在上层把多组RAID 5构成Stripe，性能比起单纯的RAID 5高，容量利用率比RAID5要低。比如同样使用9颗硬盘，由各3颗RAID 5再组成RAID 0的RAID 50，每组RAID 5浪费一颗硬盘，利用率为(1-3&#x2F;9)，RAID 5则为(1-1&#x2F;9)。</p>
<p><img src="https://pic3.zhimg.com/50/8c26881d67c3fc5d88b2172bbed85f48_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/8c26881d67c3fc5d88b2172bbed85f48_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>### RAID 60</strong></p>
<p>RAID 6与RAID 0的组合：先作RAID 6，再作RAID 0。换句话说，就是对两组以上的RAID 6作Stripe访问。RAID 6至少需具备4颗硬盘，所以RAID 60的最小需求是8颗硬盘。</p>
<p>由于底层是以RAID 6组成，所以RAID 60可以容许任一组RAID 6中损毁最多2颗硬盘，而系统仍能维持运作；不过只要底层任一组RAID 6中损毁3颗硬盘，整组RAID 60就会失效，当然这种情况的概率相当低。</p>
<p>比起单纯的RAID 6，RAID 60的上层通过结合多组RAID 6构成Stripe访问，因此性能较高。不过使用门槛高，而且容量利用率低是较大的问题。</p>
<p><img src="https://pic1.zhimg.com/50/7d1922f356f6e2be74cdae8c3cc8b2ac_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/7d1922f356f6e2be74cdae8c3cc8b2ac_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>## 关于RAID参数调优</strong></p>
<p>&gt; 通常情况下建议系统(RAID1)与数据(RAID[5|10])分离，这里引用@叶金荣老师的一段话</p>
<p>\1. 使用SSD或者PCIe SSD设备，至少获得数百倍甚至万倍的IOPS提升<br>\2. 购置阵列卡同时配备CACHE及BBU模块，可明显提升IOPS（主要是指机械盘，SSD或PCIe SSD除外。同时需要定期检查CACHE及BBU模块的健康状况，确保意外时不至于丢失数据）<br>\3. 有阵列卡时，设置阵列写策略为WB，甚至FORCE WB（若有双电保护，或对数据安全性要求不是特别高的话），严禁使用WT策略。并且闭阵列预读策略<br>\4. 尽可能选用RAID-10，而非RAID-5(<code>这句话有待商榷</code>)<br>\5. 使用机械盘的话，尽可能选择高转速的，例如选用15KRPM，而不是7.2KRPM的盘，不差几个钱的；</p>
<p><strong>## SSD阵列卡方案优化</strong></p>
<p>&gt; 感谢@小米noops运维团队，详细实验数据请参考扩展阅读</p>
<p><img src="https://pic1.zhimg.com/50/c4132b7b42d2758db39d1644ee5a3963_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/c4132b7b42d2758db39d1644ee5a3963_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><img src="https://pica.zhimg.com/50/c76b4b4d0d3877d242ccbc037e3c3aff_720w.jpg?source=1940ef5c" alt="img"><img src="https://pica.zhimg.com/80/c76b4b4d0d3877d242ccbc037e3c3aff_1440w.jpg?source=1940ef5c" alt="img"></p>
<p><strong>性能测试结论</strong></p>
<p>性能测试显示，相同容量的R50和R10性能接近：其中小块文件的随机读R50要全面好于R10，随机写4K虽然R50和R10差距在28%，但是块增大后R50要全面优于R10。顺序读写方面，R50和R10十分接近。</p>
<p>容错方面，R50接近R10：第二块盘容错率R50十分接近R10，两者相差30%。R10的优势主要是在有一定的概率提供第三、甚至第四块磁盘的容错率，但是考虑到并非100%容错，因此从容错角度来看R50虽然和R10有一些差距，但也已体现出较好的容错率，至少优于R5。而且R50搭配灵活，甚至可以指定3组R5以达到最大3块磁盘的容错；</p>
<p>成本方面，R50有很大优势：按这个配置计算R50只有R10的3&#x2F;4。</p>
<p><strong>总结</strong></p>
<p>RAID 50提供了接近RAID 10性能、可用性以及接近RAID 5成本的特性，具有较好的整体性价比优势，所以考虑使用RAID 50替换RAID 10吧</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zengjunjie1026.github.io/2023/08/16/%E7%BE%A4%E6%99%96%E5%8F%98%E8%BA%ABairdrop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="andrew">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分子美食家的博客">
      <meta itemprop="description" content="做自己爱做的事，爱自己在做的事！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 分子美食家的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/16/%E7%BE%A4%E6%99%96%E5%8F%98%E8%BA%ABairdrop/" class="post-title-link" itemprop="url">群晖变身airdrop</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-16 21:09:19 / 修改时间：21:09:33" itemprop="dateCreated datePublished" datetime="2023-08-16T21:09:19+08:00">2023-08-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>把群晖 NAS 变成「时间返回舱」，轻松搞定 Time Machine 无线备份</p>
<p>2018年11月18日</p>
<p>相比 Windows 自带的系统还原功能，macOS 有着更加完善的备份还原机制：通过内置的 Time Machine，我们可以方便地进行整机备份，在关键时候成为系统以及重要资料一颗「后悔药」。</p>
<p>当然，如果需要使用 Time Machine 功能备份，苹果官方提供了两种方式，无论哪一种方式，你都需要外置的存储来解决：一种是准备一个较合适容量的移动硬盘，如果你正好有一个闲置不用的移动硬盘，拿出来做专门的 Mac 的 Time Machine 备份倒是不错，只不过就会比较麻烦——每一次备份都需要插入移动硬盘。</p>
<p>还有一种是使用网络存储器，比如说苹果官方的高存储容量 AirPort Time Capsule（时间返回舱），设置一次就可以轻松完成自动备份工作，但其售价高昂不说，现在也已经全面在苹果在线商店下架，显然无论是从经济角度还是便利性角度而言，以上两个方案似乎都并不合适。</p>
<p>其实，如果你恰好有一台群晖 NAS ，就可以将其轻松打造成一个稳定可靠的「时间返回舱」，而该功能从入门级的 J 系列就已经默认搭载，换句话说，你几乎没有什么额外成本就可以拥有和 AirPort Time Capsule 近乎一样的功能，那么如何使用 Time Machine 将 Mac 文件备份至群晖呢？</p>
<h2 id="如何让群晖-NAS-支持-Time-Machine-功能？"><a href="#如何让群晖-NAS-支持-Time-Machine-功能？" class="headerlink" title="如何让群晖 NAS 支持 Time Machine 功能？"></a>如何让群晖 NAS 支持 Time Machine 功能？</h2><p>要想让群晖支持 Time Machine ，还需要对群晖进行一番设置，首先我们使用管理员账号登录群晖的 DSM 系统1 ，首先来创建一个共享文件夹，专门用来存放 Time Machine 的备份数据：</p>
<p>登录到 DSM 之后，点击「控制面板 - 共享文件夹」，点击「创建」来添加共享文件夹。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/ac135adbe134d0703a7acac6bbc4a04c.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>然后输入共享文件夹的名字2 ，然后选择一个所在位置（单盘 NAS 选择默认）：</p>
<p><img src="https://cdn.sspai.com/2018/11/18/7992d79626fd2f571cae842bde49b2c1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>后面一步就是是否需要加密，因为我是本地家庭环境使用，为了减少一些不必要的麻烦直接跳过，如果你是在公司中来操作则建议设置加密，然后点击下一步。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/940f3d290ab4cb4f91a7e6ee58d08d49.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>后面是为共享文件夹配置高级功能，这里我就直接跳过，然后确认设置下面选择应用。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/57993635211b319945fe96921a7ef000.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>最后会弹出读取权限的设置，这里面默认应该只有管理员（当前你登录的账户）读写权限，这里默认不修改，点击确定生成分享文件夹。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/a715c3349fbeca61d476e5050bb05bcf.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>现在你应该可以看到名为 Time Machine Folder 新共享文件夹了，下面进入到下一步，为这个文件夹配可访问的账号。</p>
<h2 id="在-NAS-中为-Time-Machine-创建管理用户"><a href="#在-NAS-中为-Time-Machine-创建管理用户" class="headerlink" title="在 NAS 中为 Time Machine 创建管理用户"></a>在 NAS 中为 Time Machine 创建管理用户</h2><p>Time Machine Folder 这个文件夹显然应该只需要有一个专门操作的账户来操作，使用管理员账号操作并不安全，因此在这里我们需要给 Time Machine 创建管理用户并为其配备的对应配额限制。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/86234695bbbb0758f2aa1d1567eca86b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>首先，还是通过群晖的管理员账户登录 DSM ，在「控制面板 - 用户」中，点击「创建用户」，输入用户名3 并设置一个复杂密码，然后点下一步，在群组中保持默认再点下一步。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/9b3e81fc108b528526b47257a8c8e7a5.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>在文件夹的权限分配这个设置页中，找到之前设置的共享文件夹「Time Machine Folder」，<strong>勾选中「读写」权限（一定要做），</strong>然后点击下一步，在用户配合设置页面中，选择存储配额。</p>
<p>这一步需要注意的是，为了避免 Time Machine 备份占用你全部的存储空间，建议设置在一个额定的空间范围内，比如我的 MacBook Pro 是 128GB 的存储，而我的群晖 NAS 的存储「空间 1」剩余 2.0 TB ，因此从使用权衡来看，选择 200GB 完全是绰绰有余，制定好之后选择下一步。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/85d0d591291cf483391f7ad169493d12.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>后续两个设置中都默认不选，直接点下一步，最后点击到应用后完成用户「Time Machine User」的新建，最后你在「控制面板 - 用户」中应该可以看到这个新建的用户了。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/cf650e3ab4e93f9bb7ec52c84e61124b.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>p.s.  如果你是在企业生产环境中，可以通过生成配对的「共享文件夹」+「对应的用户」来创建多个 Time Machine 备份空间，这样可以为多台 Mac 设备开启单独的备份，管理也更方便。</p>
<h2 id="在-NAS-中开启相关文件服务"><a href="#在-NAS-中开启相关文件服务" class="headerlink" title="在 NAS 中开启相关文件服务"></a>在 NAS 中开启相关文件服务</h2><p>前面共享文件夹和相关的访问用户已经设置完毕，那么接下来就是对相关的文件夹进行一系列的设置。首先在群晖的「控制面板 - 文件服务」设置中，找到 <strong>SMB&#x2F;AFP&#x2F;NFS</strong> 选项卡，然后点击勾选 启用 SMB 服务以及 AFP 服务。注意下方生成的访问地址，例如我这里生成的 SMB 访问地址：<code>smb://DS215J</code>。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/9a0808946eb2a9d0c1e4cebe4919a8bb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>然后切换到高级设置中，在 Bonjour 中勾选「启用 Bonjour 服务发现」，以及下方的「启用通过 SMB 进行 Bonjour Time Machine 播送」和「启用通过 AFP 进行 Bonjour Time Machine 播送」，然后点击下方的设置 Time machine 文件夹，选择之前我们建立的 「Time Machine Folder」共享文件夹点击确定即可。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/dbf8339cefcd9273213e57735e8c8d4d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>p.s. 如果你的环境中，Mac 设备的系统版本在 10.12 以上，那么只需要启用 SMB 相关服务即可，可以不用勾选 AFP 服务。</p>
<p>至此，在群晖上的相关设置就全部完成了，换言之，这时候的群晖已经脱胎换骨成为一台「时间返回舱」了。</p>
<h2 id="让-Mac-的-Time-Machine-备份至-NAS"><a href="#让-Mac-的-Time-Machine-备份至-NAS" class="headerlink" title="让 Mac 的 Time Machine 备份至 NAS"></a>让 Mac 的 Time Machine 备份至 NAS</h2><p>接下来的步骤就是在 Mac 上设置时间机器，然后将备份目的地改成刚才设置好的群晖，首先在我们需要可以让 Mac 访问群晖中的备份文件夹。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/c67463c703df1874de7c6318052b2430.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>打开访达，在菜单中点击「前往 - 连接服务器」，然后输入 NAS 的 smb 地址，例如我这里的 <code>smb://DS215J</code>，然后点击链接，在输入之前设置的账户名和密码之后，在弹出的文件夹中，选择时间机器的备份文件夹，之后点击好完成装载。</p>
<p><img src="https://cdn.sspai.com/2018/11/18/1f1c1dea15242ee5d673acbdbc7e7429.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="img"></p>
<p>接下来从 Dock 栏中打开「系统偏好设置」，在「时间机器」中选择「备份磁盘」，然后选择之前链接的群晖对应的文件夹，然后点击使用磁盘。</p>
<p>这时候还有可能会要求输入之前在群晖中创建的账户和密码，然后点击链接，然后时间机器会自动绑定群晖设置到了备份目的磁盘，然后到这里你的时间机器就算是真正意义上的设置好了，如果不出意外的话就会自动开始进行备份工作。</p>
<p>通过一连串的操作之后，你的群晖可以轻松化身为一台「廉价版 AirPort Time Capsule」，为你的 Mac 设备保驾护航，而无论是性价比上还是便利性上都可以称作是 Mac 时间机器的最佳解决方案，如果你恰好有一台 Mac 和群晖设备，不妨试试这个方案来打造一个最廉价的时间机器备份方案。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zengjunjie1026.github.io/2023/08/16/kubeflow%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="andrew">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="分子美食家的博客">
      <meta itemprop="description" content="做自己爱做的事，爱自己在做的事！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 分子美食家的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/16/kubeflow%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">kubeflow基础搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-08-16 18:02:52 / 修改时间：21:29:03" itemprop="dateCreated datePublished" datetime="2023-08-16T18:02:52+08:00">2023-08-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">andrew</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
